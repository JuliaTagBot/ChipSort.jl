<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms in detail · ChipSort.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="ChipSort.jl logo"/></a><h1>ChipSort.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">ChipSort.jl Documentation</a></li><li><a class="toctext" href="../theory/">Theory</a></li><li class="current"><a class="toctext" href>Algorithms in detail</a><ul class="internal"><li><a class="toctext" href="#Sorting-networks-1">Sorting networks</a></li><li><a class="toctext" href="#Bitonic-merge-networks-1">Bitonic merge networks</a></li></ul></li><li><a class="toctext" href="../api/">API</a></li><li><a class="toctext" href="../benchmark/">Benchmark</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Algorithms in detail</a></li></ul><a class="edit-page" href="https://github.com/nlw0/ChipSort.jl/blob/master/docs/src/algo-detail.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Algorithms in detail</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Algorithms-in-detail-1" href="#Algorithms-in-detail-1">Algorithms in detail</a></h1><p>Most of ChipSort.jl was implemented as generated functions, a very interesting and powerful Julia feature for meta-programming. Programming can be difficult, but meta-programming takes it to another level! It may be hard to figure out how our functions work by just reading the code. Something that might help is to look at some of the generated code instead.</p><h2><a class="nav-anchor" id="Sorting-networks-1" href="#Sorting-networks-1">Sorting networks</a></h2><p>Sorting networks are built from a fundamental operation, the comparator, that takes two values in and outputs them in order. By organizing these comparators correctly we can build a network that takes in a sequence of multiple values and outputs the sorted sequence. For the sake of efficiency, when designing such a network we try to use as few operations as possible and also allow them to occur in parallel.</p><center><img src="../assets/sorting-network-4.svg" width="70%"/></center><p>Figure 1 shows a sorting network for 4 elements. It has three steps, inside of which all operations might be carried out in parallel. These steps form a pipeline where a sequence output by one step is the input to the next one.</p><p>The topology of a network is described by a sequence of sets of pairs. Each inner list describes one of the steps from the pipeline. This is how the network from Figure 1 is described <a href="https://github.com/nlw0/ChipSort.jl/blob/5f919bd33e63d188b750b3809c299c46afae62c3/src/sorting-network-parameters.jl#L7">in our codebase</a>. Using arrays, we can represent that network as:</p><pre><code class="language-julia">network = [[(1,2), (3,4)], [(1,3), (2,4)], [(2,3)]</code></pre><p>Carrying out the operations could then be done like this:</p><pre><code class="language-julia">for step in 1:N
	for (a,b) in network[step]
		seq[a], seq[b] = minmax(seq[a], seq[b])
	end
end</code></pre><p>What we actually do in our generated function is essentially to unroll this loop, and represent each sequence value at each step as a transient program variable.</p><p>Generated functions work like this: it is a function that takes as arguments the types of the arguments of the function you are going to generate. We then output a Julia <code>Expr</code> object which is the body of the function. Julia then compiles and runs this function.</p><p>Another way to do the same thing in Julia would be to have some function that builds definitions and then <code>eval</code> them. This is a more flexible and perhaps explicit way of doing things, with a different name for your <em>generating</em> and <em>generated</em> functions. Julia&#39;s <code>@generated</code> functions are just a convenience that lets you declare this meta-programming function the same way as you would declare the functions it generates. It might seem to confuse things a bit, but once you start working with meta-programming building expressions and running <code>eval</code> it becomes clear this is a very nice and handy concept.</p><p>Executing our sorting network function with 4 values outputs a sorted tuple.</p><pre><code class="language-none">julia&gt; sort_net(43, 17, 81, 2)
(2, 17, 43, 81)</code></pre><p>If we simply remove the <code>@generated</code> from the function declaration what we get instead is the function body that we generated.</p><pre><code class="language-none">julia&gt; include(&quot;non-generated-sorting-networks.jl&quot;)
julia&gt; sort_net(43, 17, 81, 2)
quote
    #= /home/user/src/ChipSort.jl/src/sorting-networks.jl:50 =#
    $(Expr(:meta, :inline))
    input_0_1 = input[1]
    input_0_2 = input[2]
    input_0_3 = input[3]
    input_0_4 = input[4]
    input_1_1 = min(input_0_1, input_0_2)
    input_1_2 = max(input_0_1, input_0_2)
    input_1_3 = min(input_0_3, input_0_4)
    input_1_4 = max(input_0_3, input_0_4)
    input_2_1 = min(input_1_1, input_1_3)
    input_2_3 = max(input_1_1, input_1_3)
    input_2_2 = min(input_1_2, input_1_4)
    input_2_4 = max(input_1_2, input_1_4)
	input_3_1 = input_2_1
    input_3_4 = input_2_4
    input_3_2 = min(input_2_2, input_2_3)
    input_3_3 = max(input_2_2, input_2_3)
    (input_3_1, input_3_2, input_3_3, input_3_4)
end</code></pre><p>As we can see, each step creates a block of assignments calculating <code>min</code> and <code>max</code> from pairs of values from the past step. The values are selected according to the network definition.</p><h2><a class="nav-anchor" id="Bitonic-merge-networks-1" href="#Bitonic-merge-networks-1">Bitonic merge networks</a></h2><p>Let&#39;s look now at the code generated for a bitonic merge network. We have again a pipeline where the number of steps is the logarithm of the number of values. At each step we take two vectors, get the pairwise <code>min</code> and <code>max</code> from them, and perform a shuffling, reordering the values across the two vectors.</p><pre><code class="language-julia">julia&gt; bitonic_merge(Vec((1, 3, 5, 7)), Vec((2, 4, 6, 8)))
(&lt;4 x Int64&gt;[1, 2, 3, 4], &lt;4 x Int64&gt;[5, 6, 7, 8])

# ...Load modified library

julia&gt; bitonic_merge(Vec((1, 3, 5, 7)), Vec((2, 4, 6, 8)))
quote
    #= /home/user/src/ChipSort.jl/src/bitonic-merge-network.jl:76 =#
    $(Expr(:meta, :inline))
    la_0 = input_a
    lb_0 = shufflevector(input_b, Val{(3, 2, 1, 0)})
    L_0 = min(la_0, lb_0)
    H_0 = max(la_0, lb_0)
    la_1 = shufflevector(L_0, H_0, Val{(0, 1, 4, 5)})
    lb_1 = shufflevector(L_0, H_0, Val{(2, 3, 6, 7)})
    L_1 = min(la_1, lb_1)
    H_1 = max(la_1, lb_1)
    la_2 = shufflevector(L_1, H_1, Val{(0, 4, 2, 6)})
    lb_2 = shufflevector(L_1, H_1, Val{(1, 5, 3, 7)})
    L_2 = min(la_2, lb_2)
    H_2 = max(la_2, lb_2)
    la_3 = shufflevector(L_2, H_2, Val{(0, 4, 1, 5)})
    lb_3 = shufflevector(L_2, H_2, Val{(2, 6, 3, 7)})
    (la_3, lb_3)
end</code></pre><p>The really tricky part is figuring out the shuffling parameters at each step. Although it is not as challenging as finding optimal sorting networks.</p><footer><hr/><a class="previous" href="../theory/"><span class="direction">Previous</span><span class="title">Theory</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
